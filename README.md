# Django Tree Menu

Тестовое задание — приложение древовидного меню на Django.

## Ключевые особенности

- **1 запрос к БД** на отрисовку каждого меню (ключевое требование)
- Меню через template tag: `{% draw_menu 'main_menu' %}`
- **DRF API** для работы с меню (демонстрация знания DRF для CRM)
- Редактирование через Django Admin
- Поддержка явных URL и named URL
- Автоматическое раскрытие пути к активному пункту
- Готовность к PostgreSQL (настройка в settings.py)

## Быстрый старт

```bash
# Установка зависимостей
pip install -r requirements.txt

# Миграции
python manage.py migrate

# Заполнение тестовыми данными
python manage.py populate_menu

# Создание суперпользователя
python create_superuser.py

# Запуск сервера
python manage.py runserver
```

## Демо

- **Сайт**: http://127.0.0.1:8000/
- **Админка**: http://127.0.0.1:8000/admin/ (admin / admin)

## Использование в шаблонах

```django
{% load menu_tags %}

{# Отрисовка меню по имени #}
{% draw_menu 'main_menu' %}
{% draw_menu 'footer_menu' %}
```

## API (DRF)

Демонстрация знания Django REST Framework (важно для CRM вакансии):

```bash
# Получить меню по имени
GET /api/menu/by-name/main_menu/

# Получить все пункты меню
GET /api/menu/?menu_name=main_menu

# Получить конкретный пункт
GET /api/menu/1/
```

Пример ответа:
```json
{
  "menu_name": "main_menu",
  "items": [
    {
      "id": 1,
      "title": "Главная",
      "url": "/",
      "children": []
    }
  ],
  "total_items": 11
}
```

## Оптимизация: как достигается 1 запрос

**Ключевая оптимизация проекта** - вместо N+1 запросов делаем ровно 1 запрос к БД.

```python
# ЕДИНСТВЕННЫЙ запрос - получаем все пункты меню
items = list(MenuItem.objects.filter(menu_name=menu_name))

# Строим дерево в Python (не в БД!)
items_dict = {item.id: item for item in items}
for item in items:
    if item.parent_id:
        items_dict[item.parent_id].children_list.append(item)
```

### Сложность алгоритма

- **Время**: O(n), где n - количество элементов меню
- **Память**: O(n) для хранения дерева
- **Запросы к БД**: **O(1)** - ровно 1 запрос независимо от размера дерева

**Почему не O(1) по времени?** Потому что нам нужно:
1. Пройти по всем элементам для индексации (O(n))
2. Пройти по всем элементам для построения связей (O(n))
3. Найти активный путь (O(n) в худшем случае)

Но это оптимально - мы не можем построить дерево быстрее чем O(n), так как нужно обработать каждый элемент.

**Главное достижение**: 1 запрос к БД вместо N+1 (где N - количество уровней вложенности).

## Структура проекта

```
treemenu/
├── models.py          # Модель MenuItem
├── admin.py           # Конфигурация админки
├── templatetags/
│   └── menu_tags.py   # Template tag draw_menu
└── management/
    └── commands/
        └── populate_menu.py  # Команда заполнения БД
```

## Модель MenuItem

| Поле      | Описание                           |
|-----------|-----------------------------------|
| menu_name | Идентификатор меню (main_menu)    |
| title     | Отображаемое название             |
| parent    | FK на родительский пункт          |
| url       | Явный URL (/about/)               |
| named_url | Имя URL из urls.py (about)        |
| order     | Порядок сортировки                |

## Логика раскрытия меню

1. Всё над активным пунктом — развернуто
2. Первый уровень под активным — развернут
3. Остальное — свернуто

## Тестирование

Проект включает полный набор тестов:

```bash
python manage.py test treemenu
```

**Покрытие тестами**:
- ✅ Модель MenuItem (валидация, URL, дерево)
- ✅ Template tag draw_menu
- ✅ DRF API endpoints
- ✅ **Оптимизация запросов** (проверка что 1 запрос к БД)

## Профессиональные улучшения

### Безопасность
- ✅ Валидация модели (защита от циклических ссылок)
- ✅ Экранирование HTML в template tag
- ✅ Проверка named_url через reverse()

### Производительность
- ✅ Индексы БД на `menu_name` и `parent_id`
- ✅ Составной индекс на `(menu_name, order)` для сортировки
- ✅ Оптимизация запросов (prefetch_related в API)

### Качество кода
- ✅ Полное покрытие тестами
- ✅ Документация в коде
- ✅ Валидация данных
- ✅ Обработка edge cases

## Соответствие требованиям вакансии

| Требование | Статус | Комментарий |
|-----------|--------|-------------|
| Python | ✅ | Чистый Python код, оптимизация алгоритмов |
| Django | ✅ | Models, Admin, Template Tags, ORM |
| **DRF** | ✅ | API ViewSet с оптимизацией |
| PostgreSQL | ✅ | Настройка в settings.py (закомментирована для dev) |
| Git | ✅ | Проект готов к коммиту |

**DRF не нужен для тестового задания**, но добавлен для демонстрации знания (важно для CRM).

---

**Технологии**: Python 3.10+, Django 5.x, DRF 3.14+, PostgreSQL-ready
